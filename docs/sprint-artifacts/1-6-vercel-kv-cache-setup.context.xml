<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>6</storyId>
    <title>Vercel KV Cache Setup</title>
    <status>drafted</status>
    <generatedAt>2025-12-01</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-6-vercel-kv-cache-setup.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>Vercel KV configured for recommendations caching</iWant>
    <soThat>dashboard loads in under 2 seconds with pre-computed data</soThat>
    <tasks>
      <task id="1" ac="1-5">Install Vercel KV dependency (@vercel/kv ^2.x)</task>
      <task id="2" ac="1,3">Create cache configuration module (src/lib/cache/config.ts)</task>
      <task id="3" ac="1,5">Create Vercel KV client wrapper (src/lib/cache/client.ts)</task>
      <task id="4" ac="2">Create cache key utilities (src/lib/cache/keys.ts)</task>
      <task id="5" ac="1,4,5">Create cache service with fallback (src/lib/cache/service.ts)</task>
      <task id="6" ac="1,2,3,4">Create recommendations cache operations (src/lib/cache/recommendations.ts)</task>
      <task id="7" ac="5">Create cache invalidation utilities (src/lib/cache/invalidation.ts)</task>
      <task id="8" ac="1-5">Create index exports (src/lib/cache/index.ts)</task>
      <task id="9" ac="1,2">Create types for cached data (src/lib/cache/types.ts)</task>
      <task id="10" ac="1,5">Test: Cache operations (tests/unit/cache/service.test.ts)</task>
      <task id="11" ac="2">Test: Key generation (tests/unit/cache/keys.test.ts)</task>
      <task id="12" ac="4">Test: Fallback behavior (tests/unit/cache/fallback.test.ts)</task>
      <task id="13" ac="1">Test: Performance (tests/unit/cache/performance.test.ts)</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Recommendations stored in Vercel KV are retrieved in less than 100ms</criterion>
    <criterion id="2">Cache keys are namespaced per user: recs:${userId}</criterion>
    <criterion id="3">TTL is set to 24 hours</criterion>
    <criterion id="4">Cache miss falls back to PostgreSQL</criterion>
    <criterion id="5">Cache utilities provide get/set/delete operations</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-1.md</path>
        <title>Epic 1 Technical Specification</title>
        <section>Story 1.6: Vercel KV Cache Setup</section>
        <snippet>Acceptance criteria detail: Cache speed &lt;100ms, user-namespaced keys (recs:${userId}), 24h TTL, PostgreSQL fallback, CRUD operations.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>Caching Strategy / ADR-004</section>
        <snippet>Vercel KV provides Redis-compatible cache layer. Pre-computed recommendations stored overnight, served to dashboard for &lt;2s load time.</snippet>
      </doc>
      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>Performance Requirements</section>
        <snippet>Dashboard must load in under 2 seconds. Recommendations pre-computed overnight and cached for instant retrieval.</snippet>
      </doc>
      <doc>
        <path>docs/ux-design-specification.md</path>
        <title>UX Design Specification</title>
        <section>Core Experience Principles - Speed</section>
        <snippet>Dashboard &lt;2s target. DataFreshnessBadge component shows cache timestamp. Pre-computed overnight processing with instant recommendations.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Overview</title>
        <section>Epic 1: Foundation - Story 1.6</section>
        <snippet>Vercel KV cache infrastructure for &lt;2s dashboard load. Keys namespaced per user, 24h TTL, fallback to PostgreSQL.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>src/lib/telemetry/config.ts</path>
        <kind>configuration</kind>
        <symbol>getTracerConfig, TracerConfig</symbol>
        <lines>1-107</lines>
        <reason>PATTERN REFERENCE: Configuration module pattern with interface, constants, and getter function. Follow same structure for cache config.</reason>
      </artifact>
      <artifact>
        <path>src/lib/telemetry/index.ts</path>
        <kind>module-exports</kind>
        <symbol>module exports</symbol>
        <lines>1-88</lines>
        <reason>PATTERN REFERENCE: Module export structure with categorized exports, JSDoc module comment, and internal vs public API separation.</reason>
      </artifact>
      <artifact>
        <path>src/lib/events/index.ts</path>
        <kind>module-exports</kind>
        <symbol>EventStore, CalculationPipeline</symbol>
        <lines>1-81</lines>
        <reason>PATTERN REFERENCE: Service class export pattern with singleton instances. Follow for CacheService.</reason>
      </artifact>
      <artifact>
        <path>src/lib/db/index.ts</path>
        <kind>client</kind>
        <symbol>db, Database</symbol>
        <lines>1-37</lines>
        <reason>INTEGRATION POINT: Database client for PostgreSQL fallback. Cache miss should use db to query recommendations.</reason>
      </artifact>
      <artifact>
        <path>src/lib/events/types.ts</path>
        <kind>types</kind>
        <symbol>CalculationEvent, PriceSnapshot</symbol>
        <lines>all</lines>
        <reason>INTEGRATION POINT: Event types define recommendation data structure. CachedRecommendations should align with SCORES_COMPUTED payload.</reason>
      </artifact>
      <artifact>
        <path>src/lib/db/schema.ts</path>
        <kind>schema</kind>
        <symbol>users, calculationEvents</symbol>
        <lines>all</lines>
        <reason>INTEGRATION POINT: Database schema defines user IDs (UUID) for cache key namespacing. Calculation events for fallback queries.</reason>
      </artifact>
      <artifact>
        <path>tests/unit/telemetry/setup.test.ts</path>
        <kind>test</kind>
        <symbol>test suite</symbol>
        <lines>all</lines>
        <reason>PATTERN REFERENCE: Test file structure with describe/it blocks, mocking pattern for external services.</reason>
      </artifact>
    </code>

    <dependencies>
      <node>
        <package name="@vercel/kv" version="^2.x" purpose="Vercel KV Redis client" required="true" />
        <package name="drizzle-orm" version="^0.44.7" purpose="PostgreSQL ORM for fallback queries" existing="true" />
        <package name="postgres" version="^3.4.7" purpose="PostgreSQL driver" existing="true" />
        <package name="zod" version="^4.1.13" purpose="Data validation for cache entries" existing="true" />
        <package name="next" version="16.0.5" purpose="Framework" existing="true" />
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="pattern">Follow module structure pattern from src/lib/telemetry/ - config.ts, service files, index.ts exports</constraint>
    <constraint type="pattern">Use TypeScript strict mode - all code must handle nullability properly</constraint>
    <constraint type="pattern">Export singleton instances for services (like eventStore, db patterns)</constraint>
    <constraint type="security">Keys namespaced by userId (UUID) for multi-tenant isolation - never share cache across users</constraint>
    <constraint type="security">Never cache sensitive data (passwords, tokens, PII)</constraint>
    <constraint type="security">Validate data types on read to prevent cache poisoning</constraint>
    <constraint type="performance">Cache operations must be non-blocking - errors should not crash application</constraint>
    <constraint type="performance">Graceful degradation: if Vercel KV unavailable, fall back to PostgreSQL silently</constraint>
    <constraint type="testing">Tests pending Vitest installation (Story 1-7) - write tests but they won't run yet</constraint>
    <constraint type="testing">Use mocks for @vercel/kv in unit tests</constraint>
    <constraint type="path">Use path aliases @/lib/cache for imports</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>CacheService</name>
      <kind>class</kind>
      <signature>
class CacheService {
  async get&lt;T&gt;(key: string): Promise&lt;T | null&gt;
  async set&lt;T&gt;(key: string, value: T, ttlSeconds?: number): Promise&lt;void&gt;
  async del(key: string): Promise&lt;void&gt;
  async invalidate(pattern: string): Promise&lt;void&gt;
}
      </signature>
      <path>src/lib/cache/service.ts</path>
    </interface>
    <interface>
      <name>getRecommendations</name>
      <kind>function</kind>
      <signature>
async function getRecommendations(userId: string): Promise&lt;{
  data: CachedRecommendations | null;
  fromCache: boolean;
  timestamp: Date | null;
}&gt;
      </signature>
      <path>src/lib/cache/recommendations.ts</path>
    </interface>
    <interface>
      <name>setRecommendations</name>
      <kind>function</kind>
      <signature>
async function setRecommendations(
  userId: string,
  data: CachedRecommendations
): Promise&lt;void&gt;
      </signature>
      <path>src/lib/cache/recommendations.ts</path>
    </interface>
    <interface>
      <name>invalidateRecommendations</name>
      <kind>function</kind>
      <signature>
async function invalidateRecommendations(userId: string): Promise&lt;void&gt;
      </signature>
      <path>src/lib/cache/invalidation.ts</path>
    </interface>
    <interface>
      <name>createRecommendationKey</name>
      <kind>function</kind>
      <signature>
function createRecommendationKey(userId: string): string // Returns `recs:${userId}`
      </signature>
      <path>src/lib/cache/keys.ts</path>
    </interface>
    <interface>
      <name>CachedRecommendations</name>
      <kind>type</kind>
      <signature>
interface CachedRecommendations {
  recommendations: Array&lt;{
    assetId: string;
    score: string; // Decimal string
    amount: string; // Decimal string
    breakdown: CriterionScore[];
  }&gt;;
  generatedAt: Date;
  criteriaVersionId: string;
  expiresAt: Date;
}
      </signature>
      <path>src/lib/cache/types.ts</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Tests use Vitest framework with describe/it/expect pattern. Unit tests in tests/unit/{module}/, integration tests in tests/integration/. Mock external services (@vercel/kv) in unit tests. Test file naming: {feature}.test.ts. Tests are pending Vitest installation (Story 1-7) but should be written following the established patterns in tests/unit/telemetry/.
    </standards>
    <locations>
      <location>tests/unit/cache/*.test.ts</location>
      <location>tests/integration/cache-flow.test.ts (future)</location>
    </locations>
    <ideas>
      <idea ac="1">Test cache get operation returns data in expected format</idea>
      <idea ac="1">Test cache set operation stores data correctly</idea>
      <idea ac="1">Test mock KV client responds within timing expectations</idea>
      <idea ac="2">Test createRecommendationKey returns correct format recs:${userId}</idea>
      <idea ac="2">Test keys include userId and never share across users</idea>
      <idea ac="3">Test TTL configuration defaults to 86400 seconds (24 hours)</idea>
      <idea ac="3">Test set operation applies TTL correctly</idea>
      <idea ac="4">Test cache miss triggers PostgreSQL fallback</idea>
      <idea ac="4">Test fallback returns correct data on cache miss</idea>
      <idea ac="4">Test KV errors do not crash application</idea>
      <idea ac="5">Test get operation returns null on miss</idea>
      <idea ac="5">Test del operation removes key</idea>
      <idea ac="5">Test invalidate clears all matching keys</idea>
    </ideas>
  </tests>
</story-context>
